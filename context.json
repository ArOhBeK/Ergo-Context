{
  "core_references": {
    "LangSpec": "https://github.com/ergoplatform/sigmastate-interpreter/blob/develop/docs/LangSpec.md",
    "ErgoScript_PDF": "https://storage.googleapis.com/ergo-cms-media/docs/ErgoScript.pdf",
    "AdvancedErgoScript_Tutorial": "https://storage.googleapis.com/ergo-cms-media/docs/AdvancedErgoScriptTutorial.pdf",
    "ErgoScript_By_Example": "https://github.com/ergoplatform/ergoscript-by-example",
    "Whitepaper": "https://storage.googleapis.com/ergo-cms-media/docs/ErgoScript.pdf"
  },
  "core_references_local": {
    "LangSpec": "./local_files/LangSpec.md",
    "ErgoScript_PDF": "./local_files/ErgoScript.pdf",
    "AdvancedErgoScript_Tutorial": "./local_files/AdvancedErgoScriptTutorial.pdf",
    "ErgoScript_By_Example": "./local_files/ergoscript-by-example-main",
    "Whitepaper": "./local_files/ErgoScript.pdf"
  },
  "agent_reference": {
    "PR_2242": "https://github.com/ergoplatform/ergo/pull/2242/files",
    "guidelines": [
      "Agents build transactions based on script logic",
      "Agents maintain invariants",
      "Agents ensure safe eUTXO transitions"
    ]
  },
  "eutxo_model": {
    "box_definition": "Value + tokens + registers + script",
    "registers": ["R4", "R5", "R6", "R7", "R8", "R9"],
    "principles": [
      "Deterministic transitions",
      "Data Inputs for read-only state",
      "State encoded via registers and tokens"
    ]
  },
  "known_issues": [
    "Unvalidated data inputs",
    "Token loss",
    "OR bypass",
    "Missing signatures",
    "Sigma edge cases",
    "Missing commit-reveal",
    "HEIGHT logic bugs",
    "Cyclic hash dependencies"
  ],
  "secure_patterns": {
    "CommitReveal": "Two-stage hashing",
    "PerpetualToken": "Token preservation",
    "MultiStage": "Script hash verification",
    "Multisig": "sigmaProp conditions",
    "Refunds": "Timeout-based recovery"
  },
  "audit_examples": {
    "folder": "./audit_examples",
    "files": [
      {
        "title": "Gluon W ErgoScript Contract AI Audit Review (Proton Docs PDF)",
        "path": "./audit_examples/Gluon W ErgoScript Contract AI Audit Review - Proton Docs.pdf"
      }
    ],
    "purpose": "Calibration examples for where an LLM audit can be correct, incorrect, or partially correct, and what kinds of details it commonly misses.",
    "observed_llm_pitfalls_from_example": [
      "Missing that a token id check exists when it is referenced indirectly (e.g., inside a tuple like oracleBoxPoolNFT).",
      "Over-recommending extra identity checks (e.g., ergoTree bytes) when a singleton NFT already uniquely identifies the box in common patterns.",
      "Producing valid findings but missing contextual cancellation/invariants (e.g., _MinFee cancels out when included on both input and output sides; singleton token amount is known to be 1 for a referenced box).",
      "Not accounting for type constraints in ErgoScript (e.g., Coll[] indexing requires Int; a Long->Int downcast may be unavoidable).",
      "Flagging theoretical numeric truncation issues without considering fixed bounds/constants (e.g., BUCKETS = 14).",
      "Missing micro-optimizations and best-practice tradeoffs (e.g., && can be smaller than allOf(); getVar is off-chain supplied and may be intentionally flexible for multiple UIs)."
    ],
    "how_to_use": [
      "Treat LLM audit findings as hypotheses; verify against LangSpec and the actual on-chain constraints.",
      "When a finding depends on off-chain transaction construction, ask whether a different backend could violate this while still satisfying the script.",
      "Cross-check your audit output against these examples and call out uncertainty."
    ]
  }
}
