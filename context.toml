[core_references]
LangSpec = "https://github.com/ergoplatform/sigmastate-interpreter/blob/develop/docs/LangSpec.md"
ErgoScript_PDF = "https://storage.googleapis.com/ergo-cms-media/docs/ErgoScript.pdf"
AdvancedErgoScript_Tutorial = "https://storage.googleapis.com/ergo-cms-media/docs/AdvancedErgoScriptTutorial.pdf"
ErgoScript_By_Example = "https://github.com/ergoplatform/ergoscript-by-example"
Whitepaper = "https://storage.googleapis.com/ergo-cms-media/docs/ErgoScript.pdf"

[core_references_local]
LangSpec = "./local_files/LangSpec.md"
ErgoScript_PDF = "./local_files/ErgoScript.pdf"
AdvancedErgoScript_Tutorial = "./local_files/AdvancedErgoScriptTutorial.pdf"
ErgoScript_By_Example = "./local_files/ergoscript-by-example-main"
Whitepaper = "./local_files/ErgoScript.pdf"

[agent_reference]
PR_2242 = "https://github.com/ergoplatform/ergo/pull/2242/files"
usage = "Off-chain agents compose transactions, maintain invariants, and ensure safe transitions."

[eutxo_model]
definition = "Box = value + tokens + registers + script"
registers = ["R4", "R5", "R6", "R7", "R8", "R9"]
principles = [
  "deterministic state transitions",
  "data inputs for read-only state",
  "state encoded in registers and tokens"
]

known_issues = [
  "unvalidated data inputs",
  "token loss / unpreserved tokens",
  "OR-branch bypass",
  "missing signatures",
  "sigma edge cases",
  "missing commit-reveal",
  "HEIGHT bugs",
  "cyclic hash dependencies",
  "script cost limit issues"
]

[secure_patterns]
CommitReveal = "two-stage commit / reveal using hashes"
PerpetualToken = "preserve tokens via OUTPUTS and script hash"
MultiStage_Workflow = "validate next-stage script via propositionBytes hash"
Multisig = "sigmaProp(pkA && pkB) or atLeast(n, keys)"
EmergencyRefund = "HEIGHT > timeout && owner key"
StateContinuation = "preserve key registers/tokens in next box"
OracleAuth = "require oracle NFT or known box id"

[agent_behavior_rules]
design = [
  "consult LangSpec and eUTXO constraints",
  "apply secure patterns",
  "validate against known_issues"
]
audit = [
  "check all spend paths and invariants",
  "verify value and token conservation",
  "ensure signature and auth correctness",
  "verify HEIGHT usage"
]

[audit_examples]
folder = "./audit_examples"
purpose = "Calibration examples for where an LLM audit can be correct, incorrect, or partially correct, and what kinds of details it commonly misses."
observed_llm_pitfalls_from_example = [
  "Missing that a token id check exists when it is referenced indirectly (e.g., inside a tuple like oracleBoxPoolNFT).",
  "Over-recommending extra identity checks (e.g., ergoTree bytes) when a singleton NFT already uniquely identifies the box in common patterns.",
  "Producing valid findings but missing contextual cancellation/invariants (e.g., _MinFee cancels out when included on both input and output sides; singleton token amount is known to be 1 for a referenced box).",
  "Not accounting for type constraints in ErgoScript (e.g., Coll[] indexing requires Int; a Long->Int downcast may be unavoidable).",
  "Flagging theoretical numeric truncation issues without considering fixed bounds/constants (e.g., BUCKETS = 14).",
  "Missing micro-optimizations and best-practice tradeoffs (e.g., && can be smaller than allOf(); getVar is off-chain supplied and may be intentionally flexible for multiple UIs)."
]
how_to_use = [
  "Treat LLM audit findings as hypotheses; verify against LangSpec and the actual on-chain constraints.",
  "When a finding depends on off-chain transaction construction, ask whether a different backend could violate this while still satisfying the script.",
  "Cross-check your audit output against these examples and call out uncertainty."
]

[[audit_examples.files]]
title = "Gluon W ErgoScript Contract AI Audit Review (Proton Docs PDF)"
path = "./audit_examples/Gluon W ErgoScript Contract AI Audit Review - Proton Docs.pdf"
